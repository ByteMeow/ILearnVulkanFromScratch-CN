## 顶点缓冲

之前创建了半天顶点描述，但真正的顶点数据仍未被指定出来，而通过创建顶点缓冲，我们的顶点数据便可以被GPU所访问并使用。

由于Vulkan比OpenGL更薄，缓冲的分配参数需要程序员手动指定。

本例中的顶点数据如下：

```c++
const std::vector<Vertex> vertices = {
    {{0.0f, -0.5f}, {1.0f, 0.0f, 0.0f}},
    {{0.5f, 0.5f}, {0.0f, 1.0f, 0.0f}},
    {{-0.5f, 0.5f}, {0.0f, 0.0f, 1.0f}}
}
```

### 创建缓冲

填充`VkBufferCreateInfo`来指定创建缓冲的属性：

* `size`：缓冲大小，单位为字节。这里使用`sizeof(vertices[0]) * vertices.size())`
* `usage`：这个缓冲给谁用。这里为`VK_BUFFER_USAGE_VERTEX_BUFFER_BIT`
* `sharingMode`：这个缓冲是否分享给多个queue。由于这里只需要提供给图形（graphics）队列，所以为`VK_SHARING_MODE_EXCLUSIVE`
* `flags`：与稀疏缓冲有关。这里先不用考虑。

声明成员变量`VkBuffer vertexBuffer`并使用`vkCreateBuffer`来通过上述属性创建顶点缓冲。在cleanup阶段（非cleanup swap chain中）使用`vkDestroyBuffer`销毁该缓冲。

缓冲创建好了，但是要注意，这里创建的缓冲只是一个标记（就像OpenGL一样），在Vulkan中我们还需要手动分配显存并绑定到这个缓冲标记上（OpenGL：我们不一样，我已经在幕后给你搞定了）。

### 显存需求

使用`vkGetBufferMemoryRequirements`获取`vertexBuffer`的内存需求，并传入到`VkMemoryRequirements`变量中，包含：

* `size`：具体占用大小。注意可能和buffer中的size不同。
* `alignment`：具体数据开始的位置偏移量。
* `memoryTypeBits`：内存种类

不同位置的显存拥有不同的分配方式和性能，所以接下来我们要为想要分配的顶点缓冲的内存需求找到最合适的内存种类（Memory Type）。

首先到底看看物理硬件能够满足什么样的需求：

```c++
VkPhysicalDeviceMemoryProperties memProperties;
vkGetPhysicalDeviceMemoryProperties(physicalDevice, &memProperties);
```

在设备内存属性`VkPhysicalDeviceMemoryProperties`结构体中有两个数组，分别为：

* `memoryTypes`：内存种类
* `memoryHeaps`：分配来源

在本例中我们不关心内存的分配来源而只关心内存的分配种类。

我们还需要保证客户端有能力去映射这一片显存中分配的buffer并且进行修改，这些属性（存在`VkMemoryPropertyFlags`枚举中）包括了：

* `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT`
* `VK_MEMORY_PROPERTY_HOST_COHERENT_BIT` 

当Buffer需求和设备能满足的需求都获取到时，就可以从设备中找到一个特定的内存种类来为之后的分配做准备了。过程如下：

```c++
uint32_t findMemoryType(uint32_t typeFilter, VkMemoryPropertyFlags properties) {
    VkPhysicalDeviceMemoryProperties memProperties;
    vkGetPhysicalDeviceMemoryProperties(physicalDevice, &memProperties);

    for (uint32_t i = 0; i < memProperties.memoryTypeCount; i++) {
        if ((typeFilter & (1 << i)) && (memProperties.memoryTypes[i].propertyFlags & properties) == properties) {
            return i;
        }
    }

    throw std::runtime_error("failed to find suitable memory type!");
}

findMemoryType(memRequirements.memoryTypeBits, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT);
```

### 显存分配

获取到需要的内存种类后，我们可以通过填充`VkMemoryAllocateInfo`结构体来指明内存分配的信息了：

* `allocationSize`：具体分配大小。传入显存需求实例的`vkGetBufferMemoryRequirements::size`成员变量
* `memoryTypeIndex`：即刚刚获得的内存种类。

调用`vkAllocateMemory`并传入上述数据，并将创建好的一片显存`VkDeviceMemory vertexBufferMemory`与之前创建的缓存标记通过`vkBindBufferMemory`进行绑定。这里我们就手动的把顶点缓冲标记和显存空间关联了起来。当然，创建的这块显存也要显式的在cleanup阶段通过`vkFreeMemory`来释放掉。

### 填充顶点缓冲

到这里，缓冲已经可以被使用，即可以向里面传入顶点数据了。”传入“在Vulkan中时通过将显存中的数据映射（mapping）到宿主内存（host memory，CPU可以访问）中了。

首先声明一个通用的`void *data`，表示一个指向映射过来的内存区域的指针，并且通过调用`vkMapMemory(device, vertexBufferMemory, 0, bufferInfo.size, 0, &data)`来使指针指向具体的内存位置。注意这里的`size`又回到了真正顶点数据的大小而不是设备底层分配的大小。

由于得到了一个`void`指针，这里可以很方便的通过`memcpy`函数将顶点数组`vertices.data()`内存拷贝到这个指针指向的一篇映射内存中。随后可以通过`vkUnmapMemory`取消内存的映射。

但有时候驱动不会立刻将这片宿主内存的内容映射到显存中（可能是Cache在作祟，为了节省带宽），所以首先可以通过`VK_MEMORY_PROPERTY_HOST_COHERENT_BIT`（刚刚在筛选过程中已经指定了）来筛选出可以和宿主保持关联一致性的显存，或者在写内存之后调用`vkFlushMappedMemoryRanges`，同时在读之前调用`vkInvalidateMappedMemoryRanges`来保证内容被提交（flush），以及宿主内存有效。但仍然要注意，在进行了上述设置的时候，显存也不会被立刻同步，而是将会在下一次`vkQueueSubmit`时一并提交过去。

### 顶点缓冲与管线的绑定

在`vkCmdBindPipeline`到`vkCmdDraw`流程之间（详见第一大章），我们需要把顶点缓冲绑定到流水线上：

```c++
VkBuffer vertexBuffers[] = { vertexBuffer };
VkDeviceSize offsets[] = { 0 };
vkCmdBindVertexBuffers(commandBuffers[i], 0, 1, vertexBuffers, offsets);
```

在`vkCmdBindVertexBuffers`方法中可以指定要绑定的内容在数组中的位置（初始位置offset和长度count）。

最终可以使用`vkCmdDraw(commandBuffers[i], static_cast<uint32_t>(vertices.size()), 1, 0, 0)`（详见第一大章）来进行绘制了。
