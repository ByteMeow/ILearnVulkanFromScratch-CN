## 多线程指令缓冲录制

在该案例中我们将要结合上客户端多线程、次级指令缓冲和 CPU 视锥体剔除来演示如何多线程录制指令缓冲。我们将绘制512个独立运动的物体（这里为了体现多线程绘制不使用实例化渲染），加上天空和和 UI overlay。一个物体对应一个次级指令缓冲，每个物体的次级指令缓冲在录制之前会判断其是否可见，若不可见则不录制（即物体的次级指令缓冲为空）。一个线程对应几个物体，即一个线程负责录制这几个物体的次级指令缓冲。

该案例使用的多线程上下文创建后生命周期直到程序结束。每一个线程可以使用一个方法来推送一个 job 到线程调度器中被该线程执行，该 job 类型为 `void()`（即使用 `std::function<void()>` 传递 job 方法，此处直接传递 lambda 表达式）。存放这些线程的线程池提供 `wait()` 原语，阻塞直到所有线程结束任务的执行。多线程方法细节此处不予讨论。

首先看一下总体流程：

* 准备多线程绘制所需要的资源：
  * 全局一个的主指令缓冲。由于这里主指令缓冲每一个 draw loop 都需要重新构建，所以此处不像之前静态指令缓冲一样每一个 framebuffer（swap chain image）一个了。
  * 多个线程，其中每一个线程分配几个物体的渲染指令录制工作。每一个线程的具体准备如下：
    * 一个 secondary command buffer 的缓冲池。这里使用 `VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT` 的 flag，因为我们会重复利用这些指令缓冲，并且向让每次提交指令缓冲时将其中的指令清空。
    * 每个物体一个次级指令缓冲。在创建缓冲时 `level` 需要指定为 `VK_COMMAND_BUFFER_LEVEL_SECONDARY`。
    * 准备每个物体的 push constants。该案例中 MVP 矩阵均通过 push constants 传入流水线。
    * 客户端每个物体的属性，例如旋转速度，以及物体经过视锥体剔除计算后的可见性布尔值。
    * 客户端多线程有关配置，此处省略。
  * 一个专门负责天空盒和 UI overlay 渲染的次级指令缓冲。
* 准备其它准备内容。
* 在每个 render loop，开始录制主指令缓冲：
  * 创建一个存放次级指令缓冲的数组 `std::vector<VkCommandBuffer> commandBuffers`；
  * 在 begin info 中绑定 Render Pass 等信息，开始录制；
  * 设置 `VkCommandBufferInheritanceInfo`，填入使用的 Render Pass 和 Framebuffer；
  * 将继承信息作为参数，执行更新天空盒的次级指令缓冲并添加到上述数组中；
  * 对每个线程添加 N 个 job，其中 N 为每个线程负责绘制物体的个数。线程 job 方法将当前线程/物体 id 和继承信息传入一个方法：
    * 检查物体位置是否在视锥体内，若不在的话标记该物体可见性布尔值为 False，并直接 `return`。
    * （若可见）对于每个物体，使用继承信息开始录制对应的次级指令缓冲，即正常流程的 binding 和 `vkCmdDraw`。
  * 阻塞并等待线程池所有线程执行完毕；
  * 查看每个线程的每个物体是否可见，若可见则将其次级缓冲添加到上述数组中；
  * 将继承信息作为参数，执行更新 UI overlay 的次级指令缓冲并添加到上述数组中；
  * 调用 `vkCmdExecuteCommands`，传入上述数组的大小和 `data()`。主指令缓冲中没有任何绘制命令，所有绘制命令都存在于数组中的次级指令缓冲中。次级指令缓冲按照数组中的排列**顺序执行**。

这个案例很好的演示了次级指令缓冲和多线程配合使用的情景。需要注意的是，在实际流程中可能不会给每一个 Mesh 配备一个次级指令缓冲，而是给每一个“指令基本不变，只会同时有效/无效”的物体配备次级指令缓冲；或完全将次级指令缓冲当成一个线程资源，一个线程对应一个次级指令缓冲并独立更新，之后将这些缓冲 reduce 到数组中供主指令缓冲更新，但是要注意，Vulkan API 不提供“Tertiary Command Buffer”，所以每一个次级指令缓冲的用途要好好衡量一番。当然，如果能使用实例化渲染时当然也要首先考虑实例化渲染，其性能比多线程指令缓冲的录制要更好一级。

