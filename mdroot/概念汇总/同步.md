# 同步 synchronization

<https://www.khronos.org/assets/uploads/developers/library/2018-xdc/Vulkan-Timeline-Semaphores-Part-1_Sep18.pdf>

<https://www.jeremyong.com/c++/graphics/gpu/vulkan/2018/11/22/vulkan-synchronization-primer.html>

正如在CPU领域所发生的种种流水线和乱序执行的危害一样，在高度并行化的GPU中，这种执行危害会更加显著，这包括：

- 向同一个队列提交的一个指令缓冲，缓冲内部指令执行顺序可能会被打乱，但由于存在 API Order，因此这种乱序执行不影响绘图顺序；
- 向同一个队列提交的不同指令缓冲，缓冲间的执行顺序也有可能被打乱；
- 向不同队列提交的指令缓冲**更没有顺序的保证**。

这些导致了执行上的乱序。

正如在传统CPU不同层级存储器之间发生的读写危害一样，GPU同样采用了不同层级的存储器，并且GPU区分内存种类（Cache，VRAM，共享内存等）；同时，GPU对数据的大规模并行吞吐导致了其特别吃内存带宽，从而其对存储器的优化会更加激进。这些因素导致了经典的 RAW, WAR, WAW 内存读写危害。

## Memory Barrier vs. Execution (Pipeline) Barrier



## 提交命令时的 CPU-GPU 同步和 Fence



## 不同队列间的 GPU-GPU 同步和 Semaphore



## Subpass Dependencies

